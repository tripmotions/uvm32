#include "config.h"
#include "uvm32.h"
#include "common/uvm32_common_custom.h"

// Precompiled binary program to print integers
// This code expects to print via syscall 0x13C (UVM32_SYSCALL_PRINTD in common/uvm32_common_custom.h)
uint8_t rom[] = {
  0x23, 0x26, 0x11, 0x00, 0xef, 0x00, 0xc0, 0x00, 0x93, 0x08, 0x80, 0x13,
  0x73, 0x00, 0x00, 0x00, 0x37, 0xf5, 0xff, 0xff, 0xb7, 0x15, 0x00, 0x00,
  0x37, 0xe6, 0xff, 0xff, 0x93, 0x06, 0xf0, 0x01, 0x13, 0x07, 0xd5, 0xcc,
  0x93, 0x87, 0x35, 0x33, 0x13, 0x08, 0x76, 0xe6, 0x93, 0x82, 0x35, 0xb3,
  0x37, 0x43, 0x00, 0x00, 0x63, 0xc8, 0xe7, 0x08, 0x93, 0x03, 0x08, 0x00,
  0x63, 0xca, 0x02, 0x07, 0x93, 0x08, 0x00, 0x00, 0x93, 0x05, 0x00, 0x00,
  0x13, 0x0e, 0x00, 0x00, 0x93, 0x0e, 0x00, 0x00, 0x13, 0x06, 0x00, 0x02,
  0x13, 0x05, 0x06, 0xfe, 0x63, 0xe2, 0xa6, 0x04, 0x33, 0x85, 0x15, 0x01,
  0x63, 0x6e, 0xa3, 0x02, 0x13, 0x05, 0x00, 0x00, 0x33, 0x8e, 0xce, 0x03,
  0xb3, 0x8e, 0x15, 0x41, 0x93, 0x08, 0x90, 0x13, 0x73, 0x00, 0x00, 0x00,
  0x13, 0x5e, 0xbe, 0x40, 0xb3, 0x8e, 0x7e, 0x00, 0x33, 0x0e, 0xee, 0x00,
  0xb3, 0x85, 0xde, 0x03, 0x93, 0xd5, 0xc5, 0x00, 0x33, 0x05, 0xce, 0x03,
  0x93, 0x58, 0xc5, 0x00, 0x13, 0x06, 0x16, 0x00, 0x6f, 0xf0, 0xdf, 0xfb,
  0x93, 0x08, 0x00, 0x14, 0x13, 0x05, 0x06, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x93, 0x83, 0x13, 0x09, 0xe3, 0xda, 0x72, 0xf8, 0x13, 0x05, 0xa0, 0x00,
  0x93, 0x08, 0x00, 0x14, 0x73, 0x00, 0x00, 0x00, 0x13, 0x07, 0x97, 0x19,
  0xe3, 0xdc, 0xe7, 0xf6, 0x37, 0x05, 0x00, 0x80, 0x13, 0x05, 0x05, 0x0e,
  0x93, 0x08, 0xb0, 0x13, 0x73, 0x00, 0x00, 0x00, 0x67, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c,
  0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x00
};

// Create an identifier for our host handler
typedef enum {
    F_PRINTD,
    F_PRINTLN,
    F_PRINTC,
} f_code_t;

// Map VM syscall UVM32_SYSCALL_PRINTD (0x13C) to F_PRINTD, tell VM to expect write of a U32
const uvm32_mapping_t env[] = {
    { UVM32_SYSCALL_PRINTD, F_PRINTD, UVM32_SYSCALL_TYP_U32_WR },
    { UVM32_SYSCALL_PRINTC, F_PRINTC, UVM32_SYSCALL_TYP_U32_WR },
    { UVM32_SYSCALL_PRINTLN, F_PRINTLN, UVM32_SYSCALL_TYP_BUF_TERMINATED_WR },
};

uvm32_state_t vmst;
uvm32_evt_t evt;
bool isrunning = false;
uint32_t led_time = 0;
bool led_state = false;

void setup(void) {
    Serial.begin(115200);
    pinMode(LED_BUILTIN, OUTPUT);
    isrunning = false;
}

void loop(void) {
    // flash LED rapidly to show main loop is still running
    if (millis() > led_time + 50) {
        digitalWrite(LED_BUILTIN, led_state);
        led_state = !led_state;
        led_time = millis();
    }

    if (isrunning) {
        uvm32_run(&vmst, &evt, 100);   // num instructions before vm considered hung

        switch(evt.typ) {
            case UVM32_EVT_END:
                isrunning = false;
            break;
            case UVM32_EVT_UVM32_SYSCALL:    // vm has paused to handle UVM32_SYSCALL
                switch((f_code_t)evt.data.syscall.code) {
                    case F_PRINTD:
                        Serial.println(evt.data.syscall.val.u32);
                    break;
                    case F_PRINTC:
                        Serial.print((char)evt.data.syscall.val.u32);
                    break;
                    case F_PRINTLN:
                        for (int i=0;i<evt.data.syscall.val.buf.len;i++) {
                            Serial.print((char)evt.data.syscall.val.buf.ptr[i]);
                        }
                        Serial.println("");
                    break;
                }
            break;
            case UVM32_EVT_ERR:
                Serial.print("Error: ");
                Serial.println(evt.data.err.errstr);
                isrunning = false;
            break;
            case UVM32_EVT_YIELD:
            break;
        }
    } else {
        Serial.println("Starting VM");
        // setup vm
        uvm32_init(&vmst, env, sizeof(env) / sizeof(env[0]));
        uvm32_load(&vmst, rom, sizeof(rom));
        isrunning = true;
        delay(2000);
    }

    return;
}
